{
  "version": 3,
  "sources": ["../src/index.ts", "../src/Tuning.ts", "../src/utils/helpers.ts", "../src/Interval.ts", "../src/utils/Bimap.ts", "../src/Solmization.ts", "../src/ToneRow.ts", "../src/MusicXML.ts", "../package.json"],
  "sourcesContent": ["export * from './Tuning';\nexport * from './Solmization';\nexport * from './Interval';\nexport * from './ToneRow';\nexport * from './MusicXML';\n", "import Fraction from 'fraction.js';\nimport { binarySearch, flipFraction, mod } from './utils/helpers';\nimport { Interval } from './Interval';\n\n/**\n * Tuning metadata.\n */\nexport type Metadata = {\n  /**\n   * Tuning name.\n   */\n  name: string;\n  /**\n   * Label (short description).\n   */\n  label?: string,\n  /**\n   * Description (long description).\n   */\n  description?: string,\n  /**\n   * Source in the literature.\n   */\n  source?: string,\n  /**\n   * Reference pitch in frequency space.\n   */\n  reference?: {\n    pitchClass: number,\n    octave: number,\n    frequency: number\n  },\n  /**\n   * Intervals description.\n   */\n  intervals?: (string | undefined)[];\n}\n\n/**\n * TUNING SYSTEM\n *\n * Given a reference tone and a target tone, a tuning returns the ratio between them.\n *\n * The fundamental interval is 2/1 between the base tone and its octave.\n * Other tones subdivide the octave interval. A finite number of tones N make up the tuning.\n * Tones are indexed according to their rank in the ordered sequence of ratios\n * tone 0 => ratio 1 (unison)\n * tone 1 => ratio 1.abc (first interval)\n * tone 2 => ratio 1.def (second interval)\n * ...\n * tone N-2 => ratio 1.xyz (next-to-last interval)\n * tone N-1 => ratio 2 (octave)\n *\n * Tones can extend beyond the octave\n * e.g. tone N+1 is equivalent to tone 1, but one octave higher.\n * In addition to representing a tone as above, we can represent it by its \"generator\":\n * - its pitch class pc \u2208 [0, N-1]\n * - its octave o \u2208 \u2124\n * such that t = pc(t) + N * o(t)\n */\nexport class Tuning {\n  /**\n   * CONSTRUCTOR\n   *\n   * @param intervals Tuning intervals\n   * The intervals will be _guaranteed_ to be sorted.\n   * The first interval will be _guaranteed_ to be the unison.\n   * The last interval will be _assumed_ to be the repeater (e.g. 2/1 the octave).\n   * @param metadata Tuning metadata\n   */\n  constructor(public intervals: Interval[], public metadata?: Metadata) {\n    this.intervals.sort(Interval.compare);\n    if (this.intervals[0].ratio.valueOf() != 1) {\n      this.intervals = [new Interval(new Fraction(1)), ...this.intervals];\n    }\n  }\n\n  /**\n   * Create a tuning from ratios or cents.\n   *\n   * @param intervals An array of ratios expressed as strings, or cents expressed as numbers\n   * @param metadata As per constructor\n   * @returns Tuning instance\n   */\n  static fromIntervals(intervals: (number|string)[], metadata?: Metadata): Tuning {\n    return new Tuning(intervals.map(interval => {\n      if (typeof interval == 'string') {\n        return new Interval(new Fraction(interval));\n      }\n      else {\n        return Interval.fromCents(interval);\n      }\n    }), metadata);\n  }\n\n  /**\n   * IS A TUNING TRANSPOSABLE?\n   *\n   * A tuning is fully transposable if all of its interval differences are equal.\n   * We will consider equality to be within the range of the \"just noticeable\" interval (5 cents).\n   */\n  private _transposable: boolean;\n  get transposable(): boolean {\n    if (this._transposable !== undefined) return this._transposable;\n\n    const first: Interval = this.intervals[1].difference(this.intervals[0]);\n    return (this._transposable = this.intervals.slice(1).every((v, i) => {\n      const next: Interval = v.difference(this.intervals[i]);\n      const diff: Interval = new Interval(flipFraction(next.difference(first).ratio, true));\n      return diff.ratio.compare(Interval.JND.ratio) < 0;\n    }));\n  }\n\n  /**\n   * STEPS OF A TUNING\n   *\n   * @returns Count of tones in the tuning\n   */\n  get steps(): number {\n    return this.intervals.length - 1;\n  }\n\n  /**\n   * OCTAVE OF A TUNING\n   *\n   * @returns The last interval in the tuning, which is considered to be the octave\n   */\n  get octave(): Interval {\n    return this.intervals[this.steps];\n  }\n\n  /**\n   * TUNE A TONE\n   *\n   * @param tone Tone to be tuned\n   * @returns Frequency ratio of the tone with respect to root tone\n   */\n  tune(tone: Tone): Interval {\n    // Get the ratio difference between the target tone and the root tone, raised to the difference in octave.\n    // The octave is always the last tone as per the definition of the `intervals` array.\n    return new Interval(\n      this.intervals[tone.pitchClass].ratio.mul(this.octave.ratio.pow(tone.octave))\n    );\n  }\n\n  /**\n   * NEAREST TONE\n   * Find the nearest tone given an interval and return difference\n   *\n   * @param interval Target interval\n   * @returns Nearest tone, interval and difference from the target\n   */\n  nearest(interval: Interval): {tone: Tone, interval: Interval, difference: Interval} {\n    // Bring the interval to the base octave.\n    const octave = Math.floor(Math.log(interval.ratio.valueOf()) / Math.log(this.octave.ratio.valueOf()));\n    const base = new Interval(interval.ratio.div(this.octave.ratio.pow(octave)));\n\n    // Search through the intervals to locate the nearest.\n    const n = binarySearch(this.intervals, base, Interval.compare);\n    if (n >= 0) {\n      // Exact match: return the pitch at the right octave.\n      return {\n        tone: new Tone(this, n, octave),\n        interval,\n        difference: new Interval(new Fraction(1))\n      }\n    } else {\n      // Partial match: find real nearest between insertion point and previous.\n      // We're guaranteed to find a previous value because the first value is always unison.\n      const m = ~n;\n      const lower = Math.abs(this.intervals[m-1].difference(base).cents);\n      const upper = Math.abs(this.intervals[m].difference(base).cents);\n      const nearest = lower < upper ? m-1 : m;\n      const nearestTone = new Tone(this, nearest, octave);\n      const nearestInterval = this.tune(nearestTone);\n      return {\n        tone: nearestTone,\n        interval: nearestInterval,\n        difference: nearestInterval.difference(interval)\n      }\n    }\n  }\n\n  /**\n   * EQUAL DIVISIONS OF THE OCTAVE.\n   *\n   * Generate an intervals array based on equal divisions of the octave.\n   * The intervals are calculated in cents, because they will be converted to ratios\n   * inside the Tuning constructor.\n   */\n  static fromEdo(divisions: number): Tuning {\n    return new Tuning(Array.from(Array(divisions + 1)).map((_, i) => {\n      return Interval.fromCents(1200 / divisions * i);\n    }));\n  }\n}\n\n/**\n * Tone in a tuning.\n */\nexport class Tone {\n  constructor(public tuning: Tuning, public pitchClass: number, public octave: number) {\n    // TODO Verify that pitch class is valid.\n  }\n\n  get pitch(): number {\n    return this.pitchClass + this.octave * this.tuning.steps;\n  }\n\n  get tune(): Interval {\n    return this.tuning.tune(this);\n  }\n\n  static fromPitch(tuning: Tuning, pitch: number): Tone {\n    return new Tone(tuning, mod(pitch, tuning.steps), Math.floor(pitch / tuning.steps));\n  }\n}\n", "import Fraction from 'fraction.js';\n\n/**\n * Escape a string to be used in regular expression.\n *\n * @param str String to escape\n * @returns escaped, RegExp-ready string\n * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions\n */\nexport function escapeRegExp(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\n/**\n * Get primes up to a given integer.\n * Uses the Sieve of Eratosthenes https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n *\n * @param max Number to reach\n * @returns all primes up to max\n * @see https://stackoverflow.com/a/12287599/209184\n */\nexport function primes(max: number): number[] {\n  const sieve: boolean[] = [], primes: number[] = [];\n  for (let i = 2; i <= max; ++i) {\n    if (!sieve[i]) {\n      // i has not been marked -- it is prime\n      primes.push(i);\n      for (let j = i << 1; j <= max; j += i) {\n        sieve[j] = true;\n      }\n    }\n  }\n  return primes;\n}\n\n/**\n * Ensure a |fraction| < 1 or > 1.\n */\nexport function flipFraction(f: Fraction, greaterThanOne = false): Fraction {\n  return greaterThanOne ?\n    (f.abs().compare(1) < 0 ? f.inverse() : f) :\n    (f.abs().compare(1) > 0 ? f.inverse() : f) ;\n}\n\n/**\n * Binary search in an array.\n *\n * @param ar Elements array that is sorted\n * @param el Target element\n * @param comp Comparison function (a,b) => n with\n *        n > 0 if a > b\n *        n < 0 if a < b\n *        n = 0 if a = b\n * @returns Index m >= 0 if match is found, m < 0 if not found with insertion point = -m-1.\n * @see https://stackoverflow.com/a/29018745/209184\n */\nexport function binarySearch<T>(ar: ReadonlyArray<T>, el: T, comp: (a: T, b: T) => number): number {\n  let m = 0;\n  let n = ar.length - 1;\n  while (m <= n) {\n    const k = (n + m) >> 1;\n    const cmp = comp(el, ar[k]);\n    if (cmp > 0) {\n      m = k + 1;\n    } else if (cmp < 0) {\n      n = k - 1;\n    } else {\n      return k;\n    }\n  }\n  return ~m;\n}\n\n/**\n * Check array equality.\n *\n * @see https://stackoverflow.com/q/7837456/209184\n */\nexport function arrayEqual<T>(ar1: ReadonlyArray<T>, ar2: ReadonlyArray<T>, comp: (a: T, b: T) => number): boolean {\n  return (\n    ar1.length === ar2.length &&\n    ar1.every((value, index) => comp(value, ar2[index]) === 0)\n  );\n}\n\n/**\n * Return array with unique values.\n *\n * @see https://stackoverflow.com/a/17903018/209184\n */\nexport function arrayUnique<T>(ar: ReadonlyArray<T>): ReadonlyArray<T> {\n  return [...new Set(ar)];\n}\n\n/**\n * Always-positive modulo function. The built-in % operator actually computes the remainder.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder\n * @see https://stackoverflow.com/a/17323608/209184\n */\nexport function mod(n: number, m: number): number {\n  return ((n % m) + m) % m;\n}\n\n/**\n * Array range.\n *\n * @see https://stackoverflow.com/a/10050831/209184\n */\nexport function arrayRange(size: number, startAt = 0): ReadonlyArray<number> {\n  return [...Array(size).keys()].map(i => i + startAt);\n}\n\n/**\n * Round to nearest decimal.\n *\n * @see https://stackoverflow.com/a/27861660/209184\n */\nexport function roundTo(n: number, r: number): number {\n  const inv = 1 / r;\n  return Math.round(n * inv) / inv;\n}\n\n/**\n * Parse a string of whitespace-separated keywords, possibly including escaped quotes.\n *\n * @param list String of whitespace-separated keywords\n * @returns Array of keywords\n * @see https://stackoverflow.com/a/46946420\n */\nexport function parseList(list: string): string[] {\n  return list.match(/\\\\?.|^$/g).reduce((p, c) => {\n    if (c === '\"') {\n      p.quote = !p.quote;\n    } else if (!p.quote && c === ' ') {\n      p.a.push('');\n    } else {\n      p.a[p.a.length-1] += c.replace(/\\\\(.)/, \"$1\");\n    }\n    return  p;\n  }, {a: [''], quote: false}).a;\n}\n", "import Fraction from 'fraction.js';\n\n/**\n * INTERVALS\n *\n * The interval is the basic building block of music.\n * It is the difference in pitch between two sounds.\n *\n * It can be represented as:\n * - a frequency ratio\n * - a number of cents (1/100 of an equally tempered semitone)\n * - a number of savarts (https://en.wikipedia.org/wiki/Savart)\n * - ...and more\n *\n * It can also be named, depending on the nomenclature being used.\n *\n */\n\nexport class Interval {\n  constructor(public ratio: Fraction) {}\n  get cents(): number { return 1200 * Math.log2(this.ratio.valueOf()); }\n  get savarts(): number { return 1000 * Math.log10(this.ratio.valueOf()); }\n  difference(reference: Interval): Interval { return new Interval(this.ratio.div(reference.ratio)); }\n  static fromRatio(ratio: string): Interval { return new Interval(new Fraction(ratio)); }\n  static fromCents(cents: number): Interval { return new Interval(new Fraction(Math.pow(2, cents / 1200))); }\n  static fromSavarts(savarts: number): Interval { return new Interval(new Fraction(Math.pow(10, savarts / 1000))); }\n  static compare(a: Interval, b: Interval): number { return a.ratio.compare(b.ratio); }\n  static JND: Interval = Interval.fromCents(5); // https://en.wikipedia.org/wiki/Just-noticeable_difference\n}\n", "/**\n * BIDIRECTIONAL MAP\n *\n * Adapted from https://github.com/ThomasRooney/typed-bi-directional-map\n */\nexport interface IBimap<K, V> extends Map<K, V> {\n  readonly size: number; // returns the total number of elements\n  get: (key: K) => V | undefined; // returns a specified element\n  getKey: (value: V) => K | K[] | undefined; // returns a specified element\n  getValue: (key: K) => V | undefined; // returns a specified element\n  set: (key: K, value: V) => this; // adds or updates the value of an element looked up via the specified key\n  setValue: (key: K, value: V) => this; // adds or updates the key of an element looked up via the specified value\n  setKey: (value: V, key: K) => this; // adds or updates the value of an element looked up via the specified key\n  clear: () => void; // removes all elements\n  delete: (key: K) => boolean; // Returns true if an element existed and has been removed, or false if the element does not exist.\n  deleteKey: (key: K) => boolean; // Returns true if an element existed and has been removed, or false if the element does not exist.\n  deleteValue: (value: V) => boolean; // Returns true if an element existed and has been removed, or false if the element does not exist.\n  forEach: (\n    callbackfn: (value: V, key: K, map: IBimap<K, V>) => void,\n    thisArg?: any\n  ) => void; // executes the provided callback once for each key of the map\n  has: (key: K) => boolean; // Returns true if an element with the specified key exists; otherwise false.\n  hasKey: (key: K) => boolean; // Returns true if an element with the specified key exists; otherwise false.\n  hasValue: (value: V) => boolean; // Returns true if an element with the specified value exists; otherwise false.\n  [Symbol.toStringTag]: 'Map'; // Anything implementing Map must always have toStringTag declared to be 'Map'. I consider this a little silly.\n  inspect: () => string; // A utility function to inspect current contents as a string\n}\n\n/**\n * Bimap without duplicates.\n */\nexport class Bimap<K, V> implements IBimap<K, V> {\n  protected keyValueMap: Map<K, V> = new Map<K, V>();\n  protected valueKeyMap: Map<V, K> = new Map<V, K>();\n\n  get size(): number {\n    return this.keyValueMap.size;\n  }\n\n  public [Symbol.toStringTag]: 'Map';\n  public [Symbol.iterator]: () => IterableIterator<[K, V]> = this.keyValueMap[Symbol.iterator];\n\n  public entries = (): IterableIterator<[K, V]> => this.keyValueMap.entries();\n  public keys = (): IterableIterator<K> => this.keyValueMap.keys();\n  public values = (): IterableIterator<V> => this.keyValueMap.values();\n\n  public get = (a: K): V | undefined => this.keyValueMap.get(a);\n  public getKey = (b: V): K | undefined => this.valueKeyMap.get(b);\n  public getValue = (a: K): V | undefined => this.get(a);\n  public set = (key: K, value: V): this => {\n    // Make sure no duplicates. Our conflict scenario is handled by deleting potential duplicates, in favour of the current arguments\n    this.delete(key);\n    this.deleteValue(value);\n\n    this.keyValueMap.set(key, value);\n    this.valueKeyMap.set(value, key);\n\n    return this;\n  };\n  public setKey = (value: V, key: K): this => this.set(key, value);\n  public setValue = (key: K, value: V): this => this.set(key, value);\n  public clear = (): void => {\n    this.keyValueMap.clear();\n    this.valueKeyMap.clear();\n  };\n  public delete = (key: K): boolean => {\n    if (this.has(key)) {\n      const value = this.keyValueMap.get(key) as V;\n      this.keyValueMap.delete(key);\n      this.valueKeyMap.delete(value);\n      return true;\n    }\n    return false;\n  };\n  public deleteKey = (key: K): boolean => this.delete(key);\n  public deleteValue = (value: V): boolean => {\n    if (this.hasValue(value)) {\n      return this.delete(this.valueKeyMap.get(value) as K);\n    }\n    return false;\n  };\n  public forEach = (\n    callbackfn: (value: V, key: K, map: IBimap<K, V>) => void,\n    thisArg?: any\n  ): void => {\n    this.keyValueMap.forEach((value, key) => {\n      callbackfn.apply(thisArg, [value, key, this]);\n    });\n  };\n  public has = (key: K): boolean => this.keyValueMap.has(key);\n  public hasKey = (key: K): boolean => this.has(key);\n  public hasValue = (value: V): boolean => this.valueKeyMap.has(value);\n  public inspect = (): string => {\n    let str = 'Bimap {';\n    let entry = 0;\n    this.forEach((value, key) => {\n      entry++;\n      str += '' + key.toString() + ' => ' + value.toString() + '';\n      if (entry < this.size) {\n        str += ', ';\n      }\n    });\n    str += '}';\n    return str;\n  };\n}\n\n/**\n * Bimap with multiple values per key.\n */\nexport class Multimap<K, V> implements IBimap<K, V> {\n  protected keyValueMap: Map<K, V> = new Map<K, V>();\n  protected valueKeyMap: Map<V, K[]> = new Map<V, K[]>();\n\n  get size(): number {\n    return this.keyValueMap.size;\n  }\n\n  public [Symbol.toStringTag]: 'Map';\n  public [Symbol.iterator]: () => IterableIterator<[K, V]> = this.keyValueMap[Symbol.iterator];\n\n  public entries = (): IterableIterator<[K, V]> => this.keyValueMap.entries();\n  public keys = (): IterableIterator<K> => this.keyValueMap.keys();\n  public values = (): IterableIterator<V> => this.keyValueMap.values();\n\n  public get = (a: K): V | undefined => this.keyValueMap.get(a);\n  public getKey = (b: V): K[] | undefined => this.valueKeyMap.get(b);\n  public getValue = (a: K): V | undefined => this.get(a);\n  public set = (key: K, value: V): this => {\n    this.delete(key);\n    this.keyValueMap.set(key, value);\n\n    const keys = this.valueKeyMap.get(value) || [];\n    this.valueKeyMap.set(value, [...keys, key]);\n\n    return this;\n  };\n  public setKey = (value: V, key: K): this => this.set(key, value);\n  public setValue = (key: K, value: V): this => this.set(key, value);\n  public clear = (): void => {\n    this.keyValueMap.clear();\n    this.valueKeyMap.clear();\n  };\n  public delete = (key: K): boolean => {\n    if (this.has(key)) {\n      const value = this.keyValueMap.get(key) as V;\n      this.keyValueMap.delete(key);\n      const keys = this.valueKeyMap.get(value).filter(k => k !== key);\n      if (keys.length > 0) {\n        this.valueKeyMap.set(value, keys);\n      } else {\n        this.valueKeyMap.delete(value);\n      }\n      return true;\n    }\n    return false;\n  };\n  public deleteKey = (key: K): boolean => this.delete(key);\n  public deleteValue = (value: V): boolean => {\n    if (this.hasValue(value)) {\n      this.valueKeyMap.get(value).forEach(key => { this.delete(key); });\n      return true;\n    }\n    return false;\n  };\n  public forEach = (\n    callbackfn: (value: V, key: K, map: IBimap<K, V>) => void,\n    thisArg?: any\n  ): void => {\n    this.keyValueMap.forEach((value, key) => {\n      callbackfn.apply(thisArg, [value, key, this]);\n    });\n  };\n  public has = (key: K): boolean => this.keyValueMap.has(key);\n  public hasKey = (key: K): boolean => this.has(key);\n  public hasValue = (value: V): boolean => this.valueKeyMap.has(value);\n  public inspect = (): string => {\n    let str = 'Multimap {';\n    let entry = 0;\n    this.forEach((value, key) => {\n      entry++;\n      str += '' + key.toString() + ' => ' + value.toString() + '';\n      if (entry < this.size) {\n        str += ', ';\n      }\n    });\n    str += '}';\n    return str;\n  };\n}\n", "import { Tuning, Tone } from './Tuning';\nimport { escapeRegExp, mod } from './utils/helpers';\nimport { Multimap } from './utils/Bimap';\n\n/**\n * SOLMIZATION SYSTEM\n *\n * To name notes, we use a common representation based on Scientific Pitch Notation (SPN):\n * - Standard note letters C, D, E, F, G, A, B\n * - An extensible set of accidentals\n *\n * We define a tuning notation map that defines how notes and accidentals map to tuning tones/pitches.\n */\nexport class Solmization {\n  regex: RegExp;\n  nameMap: Multimap<string, number>;\n  parseMap: Multimap<string, number>;\n\n  /**\n   * CONSTRUCTOR\n   *\n   * @param tuning Tuning being named\n   * @param notes Map of note letters to pitch classes:\n   * ```\n   * {\n   *   'C': 0,\n   *   'D': 2,\n   *   'E': 4,\n   *   'F': 5,\n   *   'G': 7,\n   *   'A': 9,\n   *   'B': 11,\n   * }\n   * @param accidentals Map of accidentals to tone steps:\n   * ```\n   * {\n   *   '\u266F': +1,\n   *   '#': +1,\n   *   '\u266D': -1,\n   *   'b': -1,\n   *   '\u266E':  0,\n   *   '\uD834\uDD2A': +2,\n   *   '\uD834\uDD2B': -2,\n   * }\n   * ```\n   */\n  constructor(\n    public tuning: Tuning,\n    public notes: {[note: string]: number},\n    public accidentals: {[accidental: string]: number}\n  ) {\n    // parseMap associates pitch classes with all possible combinations of note letters and accidentals.\n    this.parseMap = new Multimap<string, number>();\n    Object.keys(notes).forEach(note => {\n      this.parseMap.set(note, notes[note]);\n      Object.keys(accidentals).forEach(accidental => {\n        this.parseMap.set(`${note}${accidental}`, mod(notes[note] + accidentals[accidental], tuning.steps));\n      });\n    });\n\n    // nameMap associates pitch classes with a subset of combinations, by selecting the FIRST accidental symbol\n    // for each tone step.\n    this.nameMap = new Multimap<string, number>();\n    Object.keys(notes).forEach(note => {\n      const steps = [0]; // The entry below sets the natural note, i.e. step == 0\n      this.nameMap.set(note, notes[note]);\n      Object.keys(accidentals).forEach(accidental => {\n        if (!steps.includes(accidentals[accidental])) {\n          this.nameMap.set(`${note}${accidental}`, mod(notes[note] + accidentals[accidental], tuning.steps));\n          steps.push(accidentals[accidental]);\n        }\n      });\n    });\n\n    // Create a regex that parses all possible combinations.\n    this.regex = new RegExp(\n      '^(' + Array.from(this.parseMap.keys()).map(escapeRegExp).join('|') + ')' +\n      '(-?\\\\d)$',\n      'i'\n    );\n  }\n\n  /**\n   * NAME A TONE\n   *\n   * @param tone Tone to be named\n   * @returns Array of strings representing the enharmonic namings of the tone\n   */\n  name(tone: Tone): string[] {\n    const names = [...this.nameMap.getKey(tone.pitchClass)];\n    return names.sort((a, b) => a.length - b.length).map(name => `${name}${tone.octave}`);\n  }\n\n  /**\n   * PARSE A NOTE\n   *\n   * @param note Target note in scientific pitch notation\n   * @returns Corresponding tone in the tuning\n   */\n  parse(note: string): Tone {\n    const match = this.regex.exec(note);\n    if (!match) {\n      throw new Error(`[Solmization.parse] Could not match note ${note}`);\n    }\n    return new Tone(this.tuning, this.parseMap.get(match[1]), parseInt(match[2], 10));\n  }\n}\n", "import { Tuning, Tone, Metadata } from './Tuning';\nimport { Solmization } from './Solmization';\n\n/**\n * TONE ROW\n *\n * We define a tone row as an non-repetitive ordered sequence of tones. It is the basic collection of tones\n * that make up many other musical objects such as triads, scales, chords, etc.\n *\n * This definition extends the usual definition of \"tone row\" used in serial composition\n * https://en.wikipedia.org/wiki/Tone_row\n *\n * It allows us to reuse the standard tone row operations (invert, reverse, transpose, rotate)\n * on other musical objects.\n */\nexport class ToneRow {\n  /**\n   * CONSTRUCTOR\n   *\n   * @param tuning The reference tuning\n   * @param tones The tones making up the row\n   * @param metadata Row metadata (label, description, source)\n   */\n  constructor(public tuning: Tuning, public tones: Tone[], public metadata?: Metadata) {\n    // Verify that tones are valid by detecting repeating pitch classes.\n    if (tones.some((tone, index) => !!tones.slice(index + 1).find(t => t.pitchClass === tone.pitchClass))) {\n      throw Error(`Found repeating pitch class in tone row.`);\n    }\n  }\n\n  /**\n   * Transpose a row to a target tone.\n   */\n  transpose(target: Tone): ToneRow {\n    return new ToneRow(this.tuning, this.tones.map(tone =>\n      Tone.fromPitch(this.tuning, target.pitch + tone.pitch)\n    ));\n  }\n\n  /**\n   * Invert a row around an axis tone.\n   */\n  invert(axis: Tone): ToneRow {\n    return new ToneRow(this.tuning, this.tones.map(tone =>\n      Tone.fromPitch(this.tuning, axis.pitch - tone.pitch)\n    ));\n  }\n\n  /**\n   * Reverse a row.\n   */\n  reverse(): ToneRow {\n    return new ToneRow(this.tuning, [...this.tones].reverse());\n  }\n\n  /**\n   * Rotate a row by cycling it a number of times.\n   */\n  rotate(cycles: number): ToneRow {\n    const c = cycles % this.tones.length;\n    return new ToneRow(this.tuning, [...this.tones.slice(c), ...this.tones.slice(0, c)]);\n  }\n\n  /**\n   * Monotonize a row, ensuring it is stricly ascending or descending, by raising or dropping pitch octaves.\n   *\n   * rotate.monotonize => chord inversion\n   */\n  monotonize(descending = false): ToneRow {\n    return new ToneRow(this.tuning, this.tones.reduce((current, next) => {\n      const last: Tone = current.length > 0 ? current[current.length-1] : next;\n      if (!descending && next.pitch < last.pitch) {\n        current.push(new Tone(this.tuning, next.pitchClass, last.octave + (next.pitchClass < last.pitchClass ? 1 : 0)));\n      } else if (descending && next.pitch > last.pitch) {\n        current.push(new Tone(this.tuning, next.pitchClass, last.octave + (next.pitchClass > last.pitchClass ? -1 : 0)));\n      } else {\n        current.push(next);\n      }\n      return current;\n    }, []));\n  }\n\n  /**\n   * Get the pitches of the tone row.\n   */\n  get pitches(): number[] {\n    return this.tones.map(tone => tone.pitch);\n  }\n\n  /**\n   * Create a tone row from given pitches.\n   */\n  static fromPitches(tuning: Tuning, pitches: number[], metadata?: Metadata): ToneRow {\n    return new ToneRow(tuning, pitches.map(pitch =>\n      Tone.fromPitch(tuning, pitch)\n    ), metadata);\n  }\n\n  /**\n   * Create a tone row from given pitches.\n   */\n  static fromPitchClasses(tuning: Tuning, pitchClasses: number[], octave: number, metadata?: Metadata): ToneRow {\n    return new ToneRow(tuning, pitchClasses.map(pitchClass =>\n      new Tone(tuning, pitchClass, octave)\n    ), metadata);\n  }\n}\n\nexport class ToneRowSolmized extends ToneRow {\n  constructor(public tuning: Tuning, public solmization: Solmization, public tones: Tone[], public metadata?: Metadata) {\n    super(tuning, tones, metadata);\n  }\n\n  static fromToneRow(row: ToneRow, solmization: Solmization): ToneRowSolmized {\n    return new ToneRowSolmized(row.tuning, solmization, row.tones, row.metadata);\n  }\n}\n", "import jstoxml, { XmlElement } from 'jstoxml';\nconst { toXML } = jstoxml;\nimport { ToneRowSolmized } from './ToneRow';\nimport { Tuning, Tone } from './Tuning';\nimport { Solmization } from './Solmization';\nimport { roundTo } from './utils/helpers';\nimport pkg from '../package.json';\n\nconst MUSICXML_VERSION = '4.0';\n\n/**\n * Export various Scalextric objects to as a MusicXML document.\n */\nexport class MusicXML {\n  static defaultOptions = {\n    'divisions': 768,\n    'time': {\n      'beats': 4,\n      'beatType': 4\n    },\n    'tempo': 60,\n  }\n\n  static accidentals = {\n    '#': 'sharp',\n    '\u266F': 'sharp',\n    '\\uE262': 'sharp',\n\n    'n': 'natural',\n    '\u266E': 'natural',\n    '\\uE261': 'natural',\n\n    'b': 'flat',\n    '\u266D': 'flat',\n    '\\uE260': 'flat',\n\n    'x': 'double-sharp',\n    '\uD834\uDD2A': 'double-sharp',\n    '\\uE263': 'double-sharp',\n\n    '##': 'sharp-sharp',\n    '\u266F\u266F': 'sharp-sharp',\n    '\\uE269': 'sharp-sharp',\n\n    'bb': 'flat-flat',\n    '\u266D\u266D': 'flat-flat',\n    '\uD834\uDD2B': 'flat-flat',\n    '\\uE264': 'flat-flat',\n\n    'n#': 'natural-sharp',\n    '\u266E\u266F': 'natural-sharp',\n    '\\uE268': 'natural-sharp',\n\n    'nb': 'natural-flat',\n    '\u266E\u266D': 'natural-flat',\n    '\\uE267': 'natural-flat',\n\n    '#x': 'triple-sharp',\n    '\u266F\uD834\uDD2A': 'triple-sharp',\n    '\\uE265': 'triple-sharp',\n\n    'bbb': 'triple-flat',\n    '\u266D\u266D\u266D': 'triple-flat',\n    '\\uE266': 'triple-flat',\n\n    // Stein-Zimmermann accidentals (24-EDO)\n    '\\uE280': 'quarter-flat',\n    '\\uE282': 'quarter-sharp',\n    '\\uE281': 'three-quarters-flat',\n    '\\uE283': 'three-quarters-sharp',\n\n    // Gould arrow quartertone accidentals (24-EDO)\n    '\\uE275': 'sharp-down',\n    '\\uE274': 'sharp-up',\n    '\\uE273': 'natural-down',\n    '\\uE272': 'natural-up',\n    '\\uE271': 'flat-down',\n    '\\uE270': 'flat-up',\n    '\\uE277': 'double-sharp-down',\n    '\\uE276': 'double-sharp-up',\n    '\\uE279': 'flat-flat-down',\n    '\\uE278': 'flat-flat-up',\n    '\\uE27A': 'arrow-down',\n    '\\uE27B': 'arrow-up',\n\n    // Arel-Ezgi-Uzdilek (AEU) accidentals\n    '\\uE446': 'slash-quarter-sharp',\n    '\\uE447': 'slash-sharp',\n    '\\uE442': 'slash-flat',\n    '\\uE440': 'double-slash-flat',\n    '\\uE443': 'quarter-flat',\n    '\\uE444': 'quarter-sharp',\n    '\\uE441': 'flat',\n    '\\uE445': 'sharp',\n\n    // Turkish folk music accidentals\n    '\\uE450': 'sharp-1',\n    '\\uE451': 'sharp-2',\n    '\\uE452': 'sharp-3',\n    '\\uE453': 'sharp-5',\n    '\\uE454': 'flat-1',\n    '\\uE455': 'flat-2',\n    '\\uE456': 'flat-3',\n    '\\uE457': 'flat-4',\n\n    // Persian accidentals\n    '\\uE461': 'sori',\n    '\\uE460': 'koron',\n  }\n\n  static durations = {\n    8: 'eighth',\n    4: 'quarter',\n    2: 'half',\n    1: 'whole',\n  }\n\n  private options: object;\n  private reference: Solmization;\n\n  constructor(\n    private title: string,\n    private objects: ToneRowSolmized[],\n    options = {}\n  ) {\n    this.options = Object.assign({}, MusicXML.defaultOptions, options);\n    this.reference = new Solmization(Tuning.fromEdo(12), {\n      'C': 0,\n      'D': 2,\n      'E': 4,\n      'F': 5,\n      'G': 7,\n      'A': 9,\n      'B': 11,\n    }, {});\n  }\n\n  convert(): string {\n    return toXML(this.convertDocument(), {\n      header: `\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE score-partwise PUBLIC \"-//Recordare//DTD MusicXML ${MUSICXML_VERSION} Partwise//EN\" \"http://www.musicxml.org/dtds/partwise.dtd\">\n      `.trim(),\n      indent: '  '\n    });\n  }\n\n  private convertDocument(): XmlElement {\n    return {\n      _name: 'score-partwise',\n      _attrs: { 'version': MUSICXML_VERSION },\n      _content: [{\n        'work': {\n          'work-title': this.title\n        }\n      }, {\n        'identification': [{\n          'encoding': [{\n            'software': `@infojunkie/scalextric ${pkg.version}`\n          }, {\n            'encoding-date': MusicXML.convertDate(new Date())\n          }]\n        }]\n      }, {\n        'part-list': {\n          _name: 'score-part',\n          _attrs: { 'id': 'P1' },\n          _content: {\n            _name: 'part-name',\n            _attrs: { 'print-object': 'no' },\n            _content: this.title\n          }\n        }\n      }, {\n        _name: 'part',\n        _attrs: { 'id': 'P1' },\n        _content: this.convertObjects()\n      }]\n    }\n  }\n\n  /**\n   * Convert tone rows to MusicXML measures.\n   *\n   * - Each tone row starts a new measure\n   * - Convert each tone in the tone row to a quarter-tone\n   * - Open a new measure as needed\n   * - When the tone row is complete:\n   *   - Fill the current measure with rests\n   *   - Close with a section barline\n   *   - Start a new system\n   *\n   * @returns array of measures.\n   */\n  private convertObjects(): object[] {\n    return this.objects.reduce((measures, object, index) => {\n      // Start new measure.\n      let measure = this.convertMeasure(measures.length + 1);\n      measures.push(measure);\n\n      // New system if needed.\n      if (index > 0) {\n        measure['_content'].push({\n          _name: 'print',\n          _attrs: { 'new-system': 'yes' }\n        })\n      }\n\n      // First measure attributes.\n      if (index === 0) {\n        measure['_content'].push({\n          'attributes': [{\n            'divisions': this.options['divisions']\n          }, {\n            'key': [{\n              'fifths': 0\n            }, {\n              'mode': 'major'\n            }]\n          }, {\n            'time': [{\n              'beats': this.options['time']['beats']\n            }, {\n              'beat-type': this.options['time']['beatType']\n            }]\n          }, {\n            'clef': [{\n              'sign': 'G'\n            }, {\n              'line': 2\n            }]\n          }]\n        }, {\n          _name: 'direction',\n          _attrs: { 'placement': 'above' },\n          _content: [{\n            'direction-type': [{\n              _name: 'metronome',\n              _attrs: { 'parentheses': 'no' },\n              _content: [{\n                'beat-unit': MusicXML.durations[this.options['time']['beatType']]\n              }, {\n                'per-minute': this.options['tempo']\n              }]\n            }]\n          }, {\n            _name: 'sound',\n            _attrs: { 'tempo': this.options['tempo'] }\n          }]\n        });\n      }\n\n      // Add object label if any.\n      if (object.metadata) {\n        measure['_content'].push({\n          _name: 'direction',\n          _attrs: { 'placement': 'above' },\n          _content: [{\n            'direction-type': [{\n              'words': object.metadata.label\n            }]\n          }],\n        });\n      }\n\n      // Loop on tones.\n      let beat = 0;\n      object.tones.forEach((tone, toneIndex) => {\n        measure['_content'].push(this.convertNote(tone, object));\n\n        // Add new measure if needed.\n        beat = (beat + 1) % this.options['time']['beats'];\n        if (beat === 0 && toneIndex < object.tones.length - 1) {\n          measure = this.convertMeasure(measures.length + 1);\n          measures.push(measure);\n        }\n      });\n\n      // Add remaining rests to the last measure.\n      if (beat > 0) while (beat++ < this.options['time']['beats']) {\n        measure['_content'].push({\n          _name: 'note',\n          _content: [{\n            _name: 'rest',\n          }, {\n            'duration': this.options['divisions'],\n          }, {\n            'type': MusicXML.durations[this.options['time']['beatType']],\n          }]\n        })\n      }\n\n      // Close the bar with a section barline.\n      measure['_content'].push(this.convertBar('right', 'light-light'));\n\n      return measures;\n    }, []);\n  }\n\n  private convertBar(location: string, style: string): object {\n    return {\n      _name: 'barline',\n      _attrs: { 'location': location },\n      _content: [{\n        'bar-style': style\n      }]\n    }\n  }\n\n  private convertMeasure(number: number): object {\n    return {\n      _name: 'measure',\n      _attrs: { 'number': number },\n      _content: [],\n    }\n  }\n\n  private convertNote(tone: Tone, object: ToneRowSolmized): object {\n    const name = object.solmization.name(tone)[0];\n    const step = name[0];\n    const accidental = this.convertAccidental(name.slice(1, -1));\n    const octave = name[name.length-1];\n\n    // Generate a pitch alteration as compared to the reference tuning.\n    const reference = this.reference.parse(`${step}${octave}`);\n    const cents = tone.tune.difference(reference.tune).cents;\n    const alter = roundTo(cents / 100, 0.05);\n\n    return {\n      _name: 'note',\n      _content: [{\n        _name: 'pitch',\n        _content: [{\n          'step': step\n        }, {\n          'alter': alter\n        }, {\n          'octave': octave\n        }]\n      }, {\n        'duration': this.options['divisions'],\n      }, {\n        'type': MusicXML.durations[this.options['time']['beatType']],\n      }, {\n        ...(accidental && accidental !== 'other' && { 'accidental': accidental })\n      }, {\n        ...(accidental && accidental === 'other' && {\n          _name: 'accidental',\n          _content: accidental,\n          _attrs: { 'smufl': name.slice(1, -1) }\n       })\n      }],\n    }\n  }\n\n  private convertAccidental(accidental): string {\n    if (!accidental.length) return null;\n    if (accidental in MusicXML.accidentals) {\n      return MusicXML.accidentals[accidental];\n    }\n    return 'other';\n  }\n\n  // Date in yyyy-mm-dd\n  // https://stackoverflow.com/a/50130338/209184\n  private static convertDate(date): string {\n    return new Date(date.getTime() - (date.getTimezoneOffset() * 60000))\n      .toISOString()\n      .split('T')[0];\n  }\n}\n", "{\n  \"name\": \"scalextric\",\n  \"version\": \"0.8.0\",\n  \"description\": \"Like Unicode, but for music. One day.\",\n  \"type\": \"module\",\n  \"types\": \"./build/types/index.d.ts\",\n  \"exports\": {\n    \"import\": \"./build/scalextric.js\",\n    \"require\": \"./build/scalextric.cjs\"\n  },\n  \"scripts\": {\n    \"build\": \"npm run build:esm && npm run build:cjs && npm run build:d.ts\",\n    \"build:esm\": \"esbuild src/index.ts --bundle --format=esm --minify --sourcemap --outfile=build/scalextric.js\",\n    \"build:cjs\": \"esbuild src/index.ts --bundle --platform=node --packages=external --minify --sourcemap --outfile=build/scalextric.cjs\",\n    \"build:d.ts\": \"tsc --emitDeclarationOnly --outDir build/types\",\n    \"build:chords\": \"python src/utils/chordtable/generate.py > data/chords.json && echo 'Generate data/chords.json file'\",\n    \"build:scala\": \"wget -q -O data/scales.zip http://huygens-fokker.org/docs/scales.zip && unzip -o data/scales.zip -d data/ && for f in data/scl/*; do iconv -f iso-8859-1 -t utf-8 \\\"$f\\\" -o \\\"$f\\\"; done\",\n    \"test\": \"npm run test:lint && npm run test:ts && npm run test:js\",\n    \"test:lint\": \"eslint src\",\n    \"test:ts\": \"node --import=tsx --test test/*.spec.ts\",\n    \"test:js\": \"node --test test/*.spec.js\"\n  },\n  \"author\": \"Karim Ratib <karim.ratib@gmail.com> (https://github.com/infojunkie)\",\n  \"license\": \"GPL-3.0-only\",\n  \"devDependencies\": {\n    \"@eslint/js\": \"^9.17.0\",\n    \"@types/jstoxml\": \"^2.0.4\",\n    \"@types/node\": \"^22.10.2\",\n    \"esbuild\": \"^0.24.0\",\n    \"eslint\": \"^9.17.0\",\n    \"ts-node\": \"^10.9.2\",\n    \"tsx\": \"^4.19.2\",\n    \"typescript\": \"^5.7.2\",\n    \"typescript-eslint\": \"^8.18.1\",\n    \"validate-with-xmllint\": \"^1.2.1\"\n  },\n  \"dependencies\": {\n    \"fraction.js\": \"^4.1.2\",\n    \"jstoxml\": \"^3.2.6\"\n  }\n}\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "Interval", "MusicXML", "Solmization", "Tone", "ToneRow", "ToneRowSolmized", "Tuning", "__toCommonJS", "import_fraction", "escapeRegExp", "str", "flipFraction", "f", "greaterThanOne", "binarySearch", "ar", "el", "comp", "m", "k", "cmp", "mod", "n", "m", "roundTo", "n", "r", "inv", "import_fraction", "Interval", "_Interval", "ratio", "reference", "Fraction", "cents", "savarts", "a", "b", "Tuning", "_Tuning", "intervals", "metadata", "Interval", "Fraction", "interval", "first", "v", "i", "next", "flipFraction", "tone", "octave", "base", "binarySearch", "Tone", "m", "lower", "upper", "nearest", "nearestTone", "nearestInterval", "divisions", "_", "_Tone", "tuning", "pitchClass", "pitch", "mod", "Multimap", "a", "b", "key", "value", "keys", "k", "callbackfn", "thisArg", "str", "entry", "Solmization", "tuning", "notes", "accidentals", "Multimap", "note", "accidental", "mod", "steps", "escapeRegExp", "tone", "a", "b", "name", "match", "Tone", "ToneRow", "_ToneRow", "tuning", "tones", "metadata", "tone", "index", "t", "target", "Tone", "axis", "cycles", "c", "descending", "current", "next", "last", "pitches", "pitch", "pitchClasses", "octave", "pitchClass", "ToneRowSolmized", "_ToneRowSolmized", "solmization", "row", "import_jstoxml", "package_default", "toXML", "jstoxml", "MUSICXML_VERSION", "MusicXML", "_MusicXML", "title", "objects", "options", "Solmization", "Tuning", "package_default", "measures", "object", "index", "measure", "beat", "tone", "toneIndex", "location", "style", "number", "name", "step", "accidental", "octave", "reference", "cents", "alter", "roundTo", "date"]
}
